#!/usr/bin/perl

# search for pacnew/pacsave/pacorig files

use File::Find;
use Getopt::Long qw(:config gnu_getopt);

my $packageDirectory = "/var/cache/pacman/pkg";

sub verify_version {
	unless (-e '/etc/arch-release') {
		warn <<"STOP";
Operating system is not supported. Supported operating systems are:
- Arch Linux
STOP
		exit 1;
	}
}

my $packages = 0;
my $files = 0;
my $untrackedFiles = 0;

sub process_options {
	GetOptions(
		"packages" => \$packages,
		"files" => \$files,
		"untracked-files" => \$untrackedFiles,
	) or die "Failed processing options\n";

	if (!$packages and !$files and !$untrackedFiles) {
		# No options were specified. Use the defaults.
		$packages = 1;
		$files = 1;
	}
}

############
# Packages #
############
sub find_toplevel_dependency_packages {
	my @packages = `pacman -Qqdt`;
	my $result = $? >> 8;
	($result == 0 or $result == 1) or die "Failed running pacman.\n";
	for my $package (@packages) {
		chomp $package;
		print "Package $package was installed as a dependency but is no longer needed by any package.\n";
	}
}

sub find_foreign_packages {
	my @packages = `pacman -Qqm`;
	my $result = $? >> 8;
	($result == 0 or $result == 1) or die "Failed running pacman.\n";
	for my $package (@packages) {
		chomp $package;
		print "Package $package was not found in the sync database.\n";
	}
}

sub find_out_of_date_packages {
	my @packages = `pacman -Qqu`;
	my $result = $? >> 8;
	($result == 0 or $result == 1) or die "Failed running pacman.\n";
	for my $package (@packages) {
		chomp $package;
		print "Package $package is out of date.\n";
	}
}

#########
# Files #
#########
sub find_partially_downloaded_packages {
	my @files = glob "$packageDirectory/*.part";
	for my $file (@files) {
		print "File $file did not finish downloading.\n";
	}
}

###################
# Untracked Files #
###################
sub scan_directory {
	my ($directory, $package_database) = @_;

	find({wanted => sub {
		unless ($package_database->{$_}) {
			print "File $_ is not owned by any package.\n";
		}
	}, no_chdir => 1}, $directory);
}

sub read_package_database {
	my %result;

	my @package_and_files = `pacman -Ql`;
	($? >> 8) == 0 or die "Failed running pacman.\n";
	for my $package_and_file (@package_and_files) {
		if (my ($package, $file) = $package_and_file =~ m/^([^ ]+) (.*)$/) {
			# Trim trailing slashes.
			$file =~ s[/$]{};
			$result{$file} = 1;
		} else {
			die "Invalid input: $package_and_file\n";
		}
	}

	return \%result;
}

sub main {
	verify_version;

	process_options;

	if ($packages) {
		find_toplevel_dependency_packages();

		find_foreign_packages();

		find_out_of_date_packages();
	}

	if ($files) {
		find_partially_downloaded_packages();
	}

	if ($untrackedFiles) {
		# The following are ignored, because they are just symlinks to directories inside /usr:
		#   bin
		#   lib
		#   lib64
		#   sbin

		# The following is ignored, because future versions will hopefully have special behavior for list+found directories:
		#   lost+found

		# The following are ignored, because they are re-generated by udev/the kernel:
		#   dev
		#   sys
		#   proc

		# The following are ignored, because they contain user files:
		#   home
		#   root

		# The following are ignored, because they contain temporary files:
		#   run
		#   tmp

		# The follow is ignored, because most files in it are not tracked by the package manager.
		#   var

		my @directories = qw(/boot /etc /mnt /opt /srv /usr);

		my $package_database = read_package_database();

		for my $directory (@directories) {
			scan_directory($directory, $package_database);
		}
	}
}

main;
